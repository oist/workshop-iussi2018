---
title: "I Have the Data...Now What? Analysis of differentially expressed genes in honey bees"
author: "Mariana Velasque"
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 5
    theme: cerulean

---

One of the most useful applications of RNA-seq is the identification of genes that are differentially expressed between two or more biological conditions of interest. This can be achieved by analysing whether changes in read count data between groups is greater than what would be expected just due to natural random variation.
<br>
In general, the differential gene expression (DGE) analysis can be performed in seven steps:
<br><br>

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
  - Setting up an RNA-Seq experiment
  - Quality control of raw reads
  - Pre-processing of raw reads (might affect results, especially for small fragments)
  - Mapping RNA-Seq reads onto a reference genome or transcriptome
  - Quantification of the expression level for each gene or isoform
  - Normalise mapped data
  - Differential gene expression analysis
  </div>
<br>
There are many software, pipelines and online resources to map and perform gene expression analysis (e.g. [Genestack](https://genestack.com/); [Galaxy](https://usegalaxy.org/)), here we will use public available data from ([He et al. 2017](http://onlinelibrary.wiley.com/doi/10.1111/1744-7917.12557/full/)) comparing queen, worker and drone larvae by RNA-Seq. The quality control of raw reads was performed using FastQC, adaptor and contaminants were trimmed using FastqMcf, raw reads were mapped to the latest version of the honeybee reference genome (Amel_4.5_scaffolds.fa) using STAR and gene quantification was performed using RSEM. Here, we will focus on the two last steps (normalization and gene expression analysis), however, the whole data flow and analysis can be later accessed (and replicated) on Genestack by emailing me at marianavelasque@gmail.com. 
<br>
After alignment of processed reads to a reference genome (or transcriptome) and consecutive estimation of gene and isoform abundance, it is possible to process the data. However, because the reads generated by most RNA-seq technologies are usually shorter than the transcripts from which they are sampled, it is not always possible to assign reads to a specific gene, especially in duplicated and paralogous genes with high sequence similarity. Moreover, alternatively spliced isoforms of the same gene can generate bias. Therefore, before comparing DGE across isoforms, samples, and experiments counts needs to be corrected for different sources of bias.
<br>
```{r setup, include=FALSE}
knitr::opts_chunk$set(cache=TRUE, fig.path='figures/')
```

```{r Delete all previously saved R objects}
#rm(list=ls(all=TRUE))
```

```{r libraries, message = FALSE, warning=FALSE}
library(tidyverse)
library(devtools)
library(statmod)
library(ggplot2)
library(magrittr)# this will allow us to string commands (UNIX pipe) like fashion using % >%
library(edgeR)
library(GOstats)
library(RSQLite)
library(Biobase)
library(gplots)
library(ggplot2)
library(WGCNA)
library(GSEABase)
library(flashClust)
library(preprocessCore)
library(RColorBrewer)
library(data.table)
library(ggplot2)
library(plotly)
library(limma)
library(dplyr)
library(kableExtra)
library(gage)
library(rGTExNetwork)
allowWGCNAThreads()
```

```{r, echo=FALSE}
setwd("~/Dropbox/Pesquisa/Post-doc/Study/Genome/Course/IUSSI_Workshop")
```

# Read count and data handlyng 
```{r }
# Read count and data handlyng 

#Make the first column as as rownames
gene_counts <- read.csv("genes_counts.csv", row.names=1)
counts<-gene_counts
#Take a look at the column names

gene_descriptions <- read.delim("gene_descriptions.txt")

#Naming the groups
Factors <- read_tsv("factors.tsv", col_types = cols()) %>% filter(sex == "female")
head(Factors)

##Removing NAs columns
Factors <- Factors[!is.na(names(Factors))]
# create factors for future plotting
sample <- as.character(Factors$sample)
age <-factor(Factors$age)
caste <-factor(Factors$caste)
```
# Data exploration and quality assessment

In early steps of data analysis quality assessment (QA) and data exploration are essential and they should precede the normalization step and the DGE testing. Because count values are usually highly skewed, counts are usually _log2_ transformed.
```{r raw vs log2 transformed data}
#Raw counts

matrix_counts = melt(as.matrix(gene_counts))
colnames(matrix_counts) = c('gene_id', 'sample', 'value')
ggplot(matrix_counts, aes(x=value, color=sample)) + geom_histogram(fill = "#525252", binwidth = 2000)

#Log2 transformation

log_counts <- log2(gene_counts + 1)
matrix_counts = melt(as.matrix(log_counts))
colnames(matrix_counts) = c('gene_id', 'sample', 'value')
ggplot(matrix_counts, aes(x=value, color=sample)) + geom_histogram(colour = "white", fill = "#525252", binwidth = 0.6)

```

Boxplots can also be used to visualise the distribution of counts across the samples
```{r Boxsplots}

#Naming groups
Factor <- read_tsv("factors.tsv", col_types = cols())
age1 <-factor(Factor$age)
caste1 <-factor(Factor$caste)
# Density plot of raw read counts (log10)
log_counts <- cpm(counts,log=TRUE)
# Check distributions of samples using boxplots and add a blue horizontal line that corresponds to the median logCPM
boxplot(log_counts, xlab="", ylab="Log2 counts per million",las=2)
abline(h=median(log_counts),col="blue")

##Now the density plot (log2)
log_counts <- log2(counts + 1)
matrix_counts = melt(as.matrix(log_counts))
colnames(matrix_counts) = c('gene_id', 'sample', 'value')
ggplot(matrix_counts, aes(x=value, color=sample)) + geom_density()

##By groups
log_counts<-as.matrix(log_counts)
par(mfrow=c(1,2),oma=c(2,0,0,0))
group.col <- c("black","blue")[Factor$caste]
boxplot(log_counts, xlab="", ylab="Log2 counts per million",las=2,col=group.col,
        pars=list(cex.lab=0.8,cex.axis=0.8))
abline(h=median(log_counts),col="blue")
title("Boxplots of logCPMs\n(coloured by groups)",cex.main=0.8)

caste.col <- c("red","black", "blue")[Factor$caste]
boxplot(log_counts, xlab="", ylab="Log2 counts per million",las=2, col=caste.col,
        pars=list(cex.lab=0.8,cex.axis=0.8))
abline(h=median(log_counts),col="blue")
title("Boxplots of logCPMs by caste",cex.main=0.8)

```

Another way to explore dissimilarities between samples is using clustering image map (CIM) or heatmaps.


```{r heatmap}

  #To reduce volume of data for this tutorial, we will select only the 50 most highly expressed genes
count_matrix  <-as.matrix(log_counts)
selected = order(rowMeans(count_matrix), decreasing=TRUE)[1:50] 
highexprgenes_counts <- count_matrix[selected,]
#Heatmap

colnames(highexprgenes_counts)<- caste1:age1
heatmap(highexprgenes_counts, col=topo.colors(60), margin=c(10,6))
```
Hierarchical clustering
```{r Hierarchical clustering }
# Get variance for genes
varian_genes <- apply(log_counts, 1, var)

#Select the top 50 most variable
selected_varian <- names(sort(varian_genes, decreasing=TRUE))[1:50]

hig_var_lcpm <- log_counts[selected_varian,]
colnames(hig_var_lcpm)<-caste1:age1
dim(hig_var_lcpm)

mypalette <- brewer.pal(11,"RdYlBu")
morecols <- colorRampPalette(mypalette)
colnames(hig_var_lcpm)
hig_var_lcpm<-as.matrix(hig_var_lcpm)
# Plot the heatmap
heatmap.2(hig_var_lcpm,col=rev(morecols(50)),trace="none", main="Top 50 most variable genes", ColSideColors=caste.col,scale="row",margins=c(10,5))
```

# Principal Component Analysis

A Principal Component Analysis (PCA) can be used to  perform a multidimensional scaling of a data and to visualise data clustering.

```{r PCA}
##Different from heatmap a higher number of genes can be used in this analysis, we will select 1000 most highly expressed genes

select = order(rowMeans(count_matrix), decreasing=TRUE)[1:1000]
highexprgenes_counts <- count_matrix[select,]
# annotate the data with condition group as labels
colnames(highexprgenes_counts)<- caste1:age1
# transpose the data to have variables (genes) as columns
data_PCA <- t(highexprgenes_counts)
dim(data_PCA)

##Calculate a dissmililatity matrix of the highly expressed gene counts and the proportion of explained variance (Eigen values)
mds <- cmdscale(dist(data_PCA), k=3, eig=TRUE)  
# k = the maximum dimension of the space on which the data will be represented
# eig = indicates whether eigenvalues should be returned
mds$eig
barplot(mds$eig, las=1, xlab="Dimensions", ylab="Proportion of explained variance (%)", y.axis=NULL, col="darkgrey")

##To visualise how many components can explain the variance on the data set, it is easier to plot the data as percentage
# transform the Eigen values into percentage
eig_per <- mds$eig * 100 / sum(mds$eig)
# plot the PCA
barplot(eig_per, las=1, xlab="Dimensions", ylab="Proportion of explained variance (%)", y.axis=NULL, col="darkgrey")
#The first component explains most of the data, but we will use the two components for plotting

##  MDS
mds <- cmdscale(dist(data_PCA)) # Performs MDS analysis 
#Samples representation
plot(mds[,1], -mds[,2], type="n", xlab="Dimension 1", ylab="Dimension 2", main="")
text(mds[,1], -mds[,2], rownames(mds), cex=0.8) 

```


### Converting counts to DGEList object

Next step is the creation of a DGEList object. It is used by edgeR to store parameter of the gene count data. We will add a group name and factors



```{r Converting to DGEList object}
# annotate the data with condition group as labels
counts<-gene_counts
colnames(counts)<- caste
##Removing "drone" columns
counts <- counts[!is.na(names(counts))]

##Creating a DGE list object 
ge_count <- DGEList( gene_counts[,  Factors$sample] , group = Factors$caste)
ge_count[,1:5]
names(ge_count)
```
<br><br>

# Normalisation

One possible bias is the sequencing depth (number of sequenced or mapped reads) of the samples. For example, if sample 1 generates twice as much reads as sample 2, it is likely that individual genes will also be duplicated, inflating DGE results. Contaminants might also cause a similar issue. The type of normalization depending on the data format, for instance, is a specific set of highly-expressed genes accounts for most of the total counts, a global scaling technic will not capture and efficiently correct for differences between high-count genes. To reduce the effect of high-count genes there are several approaches:

  - Quantile normalization (Q): more recommended for extreme cases 
  - Trimmed Mean of M-values (TMM) normalization: accounts for differences in library composition between samples by removing 30% of genes that are characterized by the most extreme M-values
  - Goodness-of-fit statistic: Assumes a Poisson model of counts to identify genes that are not differentially expressed between experimental groups 
  -  Reads per kilobase per million mapped reads (RPKM): reescales gene counts to correct for differences in both library size and gene length 
  - Estimated RPKM (ERPKM): improvement of RPKM using effective read length.
  - Transcripts Per Million(TPM): is a measurement of the proportion of transcripts in your pool of RNA
  - Counts per million (CPM): counts are scaled by the number of sequenced fragments times one million (similar to the FPKM without length normalization and a factor of 10^3)
  - Fragments Per Kilobase of transcript per Million mapped reads (FPKM)
  - Spike in calibration: calibrates counts data to an external reference point


```{r  BCV plot}
# Create a design
design <- model.matrix(~ 0 +caste + age)
head(design)
##First explore data overdispersion using BCV plot 

BCV_plot <- estimateDisp(ge_count, design, robust=TRUE)
plotBCV(BCV_plot)

## Plots using a DGEList object
none_norm=voom(ge_count,design,plot=T, normalize="none")
quantile_norm=voom(ge_count,design,plot=T, normalize="quantile")
scale_norm=voom(ge_count,design,plot=T, normalize="scale")
TMM_norm=calcNormFactors(ge_count,method =c("TMM"))
TMM_plot=voom(TMM_norm,design,plot=T)
upquart_norm=calcNormFactors(ge_count,method =c("upperquartile"))
TMM_plot=voom(upquart_norm,design,plot=T)
```

# Differential Expression

Before performing the gene expression analysis we need to define a design matrix. Normalise read counts and apply a linear model to the normalised data

```{r}
# Substitute "caste" from the design column names
colnames(design)<- gsub("caste","",colnames(design))
log_counts<-as.matrix(log_counts)
## Calculate the normalization factors
norm_fact <- calcNormFactors(ge_count)
plotMDS( norm_fact)

#Normalise read counts
voom_norm  <- voom(norm_fact,design,plot=TRUE)

par(mfrow=c(1,2))
boxplot(log_counts)
abline(h=median(log_counts),col=4)
boxplot(voom_norm$E)
abline(h=median(voom_norm$E),col=4)
```

##Test for differential expression

```{r}
fit <- lmFit(voom_norm,design)

fit <- eBayes(fit)
results <- decideTests(fit)
summary(results)

plotMD(fit,column=1,status=results[,2], main=colnames(fit)[1],xlim=c(-8,13))
vennDiagram(results[,1:3],circle.col=c("turquoise", "salmon", "green"))
write.fit(fit, results, file ="results.txt")
```

# Gene Annotation

The annotation of gene IDs from RNA-seq data can be done using data from databases (BioMart is recommended). We will use our own library.

```{r}
#Check if the "gene_description" file matches exactly to our fit row name
head(gene_descriptions)

##Make sure the rows matches
table(gene_descriptions$gene_id==rownames(fit))

##Make them match
gene_descriptions<- gene_descriptions[match(rownames(fit), gene_descriptions$gene_id),]

# Slot the annotation information into the genes slot of fit.
fit$genes <- gene_descriptions
head(fit$genes)

#Check if the annotation was included in the output
queenvsworker<-topTable(fit,coef=3,sort.by="p") #allocated in "description"
head(queenvsworker)

##Check the expression of vitellogenin
ps <- grep("vitellogenin",fit$genes$description)
topTable(fit[ps,],coef=3)
##Check the expression of insulin-like peptide 2
ps <- grep("insulin-like peptide",fit$genes$description)
topTable(fit[ps,],coef=3) # positive logFC means upregulated in the queen

par(mfrow=c(1,2))
plotMD(fit,coef=3,status=results[,"worker"])
volcanoplot(fit,coef=3,highlight=100,names=fit$genes$gene_id)

# View heatmap of top 100 DE genes between Basal and LP cells.
library("gplots")

stripchart(voom_norm$E["ILP-2",]~Factors$caste)
stripchart(voom_norm$E["ILP-2",]~Factors$age)

## Testing differential expression relative to a threshold
fit.treat <- treat(fit,lfc=1)
res.treat <- decideTests(fit.treat)
summary(res.treat)

topTreat(fit.treat,coef=3)

plotMD(fit.treat,coef=3,status=res.treat[,"worker"])
abline(h=0,col="grey")
```

#Weighted gene co-expression network analysis

Co-expression network analysis is an approach that builds gene networks that have a tendency to appear co-activated across a group of experimental samples. Although gene co-expression networks can be used for various purposes (i.e.identification of regularoty networks, candidate disease gene prioritization, functional gene annotation), co-expression netwroks are only effective on the identification of  correlations and thus, there its use on differential (co-expression) analysis is increaseing. A modification of this analysis is the Weighted gene co-expression network (WGCNA). In a weighted network, all genes are assumed to be connected, and such connections have continuous weight values that indicats the strength of co-regulation between the genes, ranging from 0 to 1. The WGCNA pipeline is as follows:
<br><br>

<style>
div.blue { background-color:#e6f0ff; border-radius: 5px; padding: 20px;}
</style>
<div class = "blue">
  - Construct a gene co-expression network 
  - Identify modules
  - Relate modules to phenotypes
  - Study inter-module relationships
  - FInd the key drivers in interesting modules
  </div>
<br>
    

```{r}
tpm<- read.csv("tpm.csv")

# Manipulate file so it matches the format WGCNA needs 
row.names(tpm) = tpm$gene_id
tpm$gene_id = NULL
tpm = as.data.frame(t(tpm)) # # transpose your data (samples as rows and genes as columns)
dim(tpm)

# Check the presence of outliers
gsg = goodSamplesGenes(tpm, verbose = 3)
gsg$allOK 

#Since the statement did not returned as TRUE, the genes didn't passed the test, remove outliers

if (!gsg$allOK)
  {if (sum(!gsg$goodGenes)>0)
       printFlush(paste("Removing genes:", paste(names(tpm)[!gsg$goodGenes], collapse= ", ")));
       if (sum(!gsg$goodSamples)>0)
           printFlush(paste("Removing samples:", paste(rownames(tpm)[!gsg$goodSamples], collapse=", ")))
       tpm= tpm[gsg$goodSamples, gsg$goodGenes]
       }
Factor <- read.csv("factors.csv")

##Data description file
rownames(Factor) = Factor$sample
Factor$sample = NULL
#Check if samples from tpm file align with "Factor" file
table(rownames(Factor)==rownames(tpm)) 

#Estimating network connectivity
A = adjacency(t(tpm),type="signed")
k = as.numeric(apply(A,2,sum))-1 # standardized connectivity
Z.k = scale(k)
thresholdZ.k = -2.5 
outlierColor = ifelse(Z.k<thresholdZ.k,"red","black")
sampleTree = flashClust(as.dist(1-A), method = "average")
#Convert traits as colours, high values will be indicated in red

traitColors = data.frame(numbers2colors(Factor$age,signed=FALSE))

datColors = data.frame(outlier = outlierColor,traitColors)

plotDendroAndColors(sampleTree,groupLabels=names(datColors),
                    colors=datColors,main="Age Dendrogram and Trait Heatmap")
```
Age 2 outlier was identified 

```{r}
# Remove outlying samples 
#remove.samples = Z.k<thresholdZ.k | is.na(Z.k)
#tpmOut = tpm[!remove.samples,]
#FactorOut = Facrors[!remove.samples,]
#save(tpmOut, FactorOut, file="SamplesAndTraits_OutliersRemoved.RData")
```
Choose a soft threshold power
```{r}
#Set a set of soft-thresholding power
powers = c(c(1:10), seq(from =10, to=30, by=1)) 
#Call network topology analysis function
sft = pickSoftThreshold(tpm, powerVector=powers, verbose =5, networkType="signed") 

plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], xlab= "Soft Threshold (power)", ylab="Scale Free Topology Model Fit, signed R^2", type= "n", main= paste("Scale independence"))
text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2], labels=powers, col="red")
abline(h=0.90, col="red")

plot(sft$fitIndices[,1], sft$fitIndices[,5], xlab= "Soft Threshold (power)", ylab="Mean Connectivity", type="n", main = paste("Mean connectivity"))
text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, col="red")

```
Construct a gene co-expression matrix and generate modules
```{r}
# Building an adjacency "correlation" matrix
enableWGCNAThreads()
softPower = 18
adjacency = adjacency(tpm, power = softPower, type = "signed")
```
Construct Networks
```{r}
#Translate the adjacency into topological overlap matrix and calculate the corresponding dissimilarity
TOM = TOMsimilarity(adjacency, TOMType="signed") # Specify network type
dissTOM = 1-TOM
```
Generate Modules
```{r}
# Generate a clustered gene tree
geneTree = flashClust(as.dist(dissTOM), method="average")

plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE, hang=0.04)

#This sets the minimum number of genes to cluster into a module
minModuleSize = 30 
dynamicMods = cutreeDynamic(dendro= geneTree, distM= dissTOM, deepSplit=2, pamRespectsDendro= FALSE, minClusterSize = minModuleSize)
dynamicColors= labels2colors(dynamicMods)
MEList= moduleEigengenes(tpm, colors= dynamicColors,softPower = 18)
MEs= MEList$eigengenes
MEDiss= 1-cor(MEs)
METree= flashClust(as.dist(MEDiss), method= "average")

save(dynamicMods, MEList, MEs, MEDiss, METree, file= "Network_allSamples_signed_RLDfiltered.RData")

#Plots tree showing the eigengenes clusters
plot(METree, main= "Clustering of module eigengenes", xlab= "", sub= "")

#Set a threhold for merging modules. 
MEDissThres = 0.0
merge = mergeCloseModules(tpm, dynamicColors, cutHeight= MEDissThres, verbose =3)
mergedColors = merge$colors
mergedMEs = merge$newMEs

mergedColors = merge$colors
mergedMEs = merge$newMEs

#plot dendrogram with module colors below it
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
moduleColors = mergedColors
colorOrder = c("grey", standardColors(50))
moduleLabels = match(moduleColors, colorOrder)-1
MEs = mergedMEs

```

Correlate traits

```{r}

#Defining the number of genes and samples
nGenes = ncol(tpm)
nSamples = nrow(tpm)

#Recalculate MEs adding the color labels

MEs0 = moduleEigengenes(tpm, moduleColors)$eigengenes
MEs = orderMEs(MEs0)
moduleTraitCor = cor(MEs, Factor, use= "p")
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples)

# Print the correlation heatmap between modules and traits
textMatrix= paste(signif(moduleTraitCor, 2), "\n(", 
                  signif(moduleTraitPvalue, 1), ")", sep= "")
dim(textMatrix)= dim(moduleTraitCor)
par(mar= c(6, 8.5, 3, 3))

# Display the corelation values with a heatmap plot
labeledHeatmap(Matrix= moduleTraitCor, 
               xLabels= names(Factor), 
               yLabels= names(MEs), 
               ySymbols= names(MEs), 
               colorLabels= FALSE, 
               colors= blueWhiteRed(50), 
               textMatrix= textMatrix, 
               setStdMargins= FALSE, 
               cex.text= 0.5, 
               zlim= c(-1,1), 
               main= paste("Module-trait relationships"))

```


```{r}
sessionInfo()
```
